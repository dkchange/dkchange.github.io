<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>網路協議 | My New Hugo Site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="TCP/IP
目前TCP/IP協議泛指現在網路公認使用的所有協議
7層
整理來講，為了方便區分這麼多協議的種類，我們將其分成了5層
各別舉個例子:
應用層 http  需要瀏覽器這種應用程式來拆包
傳輸層 TCP   需要三向交握確認連線
網路層 IP    需要IP當地址
連結層 ARP   需要找出實體MAC
物理層 網路線
這些協議，從瀏覽器發出封包時，經過機器，需要的資料會一層包過一層
請求
在傳輸層裡，每一個封包都需要回覆收到，沒收到的話，會將該請求反覆重試，然而使用者自在F12裡面只會看到一次請求，事實上網路線裡面的資料已經來來回回好幾百次
封包大小
每一層的協議都有規定其封包大小，其中IPV4最大為 65575 bytes大概就65kb左右
然後封包又包在幀裡面
乙太網路
在數據連結層會用到的技術名，一開始用於區域網路(微星狀或匯流排)的傳輸
連結層會用到MAC，知道兩台電腦的MAC就可以互向通信
網際網路
從網路層開始，有了IP開始了點對點的傳輸
回環地址 127.0.0.1
廣播地址 區網內最後一個IP位址，所以沒有一定
每個路由器會緩存一個到下個IP的路由表
有了ARP協議，每個請求有ARP緩存，裡面紀錄了下一個節點IP和MAC對應，這個緩存到了下一個節點就又會變動
乙太網路使用MAC來傳輸數據，但是光有MAC是無法連到網路上其他MAC地址，因為你沒有IP，不知道去哪找MAC，試想一下，如果當初沒有IP這個設計出現，那要維護全世界的MAC表這個數據量會有多龐大，所以IP和MAC缺一不可
ifconfig
ifconfig 命令归属于 net-tools 工具集。net-tools 起源于 BSD，自 2001 年起，Linux 社区已经停止对其进行维护。
一些 Linux 发行版已经停止支持 net-tools，只支持 iproute2，在这些 Linux 版本中，只能使用 ip addr 命令查看 IP 地址，使用 ifconfig 会提示命名不存在
port號
傳輸層，port號是一個虛擬的概念，並無實際上的硬體做對應，大概來說每個port號可以對應道不同的程序，為什麼有65535的限制是因為TCP當初協定定義是2的16次方-1，並不是有什麼硬體限制
标准既定的端口号（静态方法: 例如HTTP 80端口，其他的軟體自定義的就落在1024 到 49151 之间
时序分配法（动态方法:例如打開wireshark，你去訪問server80端口，就會看到很多介於49152 到 65535 之间這種由作業系統分配的暫時的port號）">
    <meta name="generator" content="Hugo 0.152.2">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    


    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/%E7%B6%B2%E8%B7%AF%E5%8D%94%E8%AD%B0/">
    

    <meta property="og:url" content="http://localhost:1313/posts/%E7%B6%B2%E8%B7%AF%E5%8D%94%E8%AD%B0/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="網路協議">
  <meta property="og:description" content="TCP/IP 目前TCP/IP協議泛指現在網路公認使用的所有協議
7層 整理來講，為了方便區分這麼多協議的種類，我們將其分成了5層 各別舉個例子: 應用層 http 需要瀏覽器這種應用程式來拆包 傳輸層 TCP 需要三向交握確認連線 網路層 IP 需要IP當地址 連結層 ARP 需要找出實體MAC 物理層 網路線
這些協議，從瀏覽器發出封包時，經過機器，需要的資料會一層包過一層
請求 在傳輸層裡，每一個封包都需要回覆收到，沒收到的話，會將該請求反覆重試，然而使用者自在F12裡面只會看到一次請求，事實上網路線裡面的資料已經來來回回好幾百次
封包大小 每一層的協議都有規定其封包大小，其中IPV4最大為 65575 bytes大概就65kb左右
然後封包又包在幀裡面
乙太網路 在數據連結層會用到的技術名，一開始用於區域網路(微星狀或匯流排)的傳輸 連結層會用到MAC，知道兩台電腦的MAC就可以互向通信
網際網路 從網路層開始，有了IP開始了點對點的傳輸 回環地址 127.0.0.1 廣播地址 區網內最後一個IP位址，所以沒有一定
每個路由器會緩存一個到下個IP的路由表 有了ARP協議，每個請求有ARP緩存，裡面紀錄了下一個節點IP和MAC對應，這個緩存到了下一個節點就又會變動
乙太網路使用MAC來傳輸數據，但是光有MAC是無法連到網路上其他MAC地址，因為你沒有IP，不知道去哪找MAC，試想一下，如果當初沒有IP這個設計出現，那要維護全世界的MAC表這個數據量會有多龐大，所以IP和MAC缺一不可
ifconfig ifconfig 命令归属于 net-tools 工具集。net-tools 起源于 BSD，自 2001 年起，Linux 社区已经停止对其进行维护。 一些 Linux 发行版已经停止支持 net-tools，只支持 iproute2，在这些 Linux 版本中，只能使用 ip addr 命令查看 IP 地址，使用 ifconfig 会提示命名不存在
port號 傳輸層，port號是一個虛擬的概念，並無實際上的硬體做對應，大概來說每個port號可以對應道不同的程序，為什麼有65535的限制是因為TCP當初協定定義是2的16次方-1，並不是有什麼硬體限制 标准既定的端口号（静态方法: 例如HTTP 80端口，其他的軟體自定義的就落在1024 到 49151 之间 时序分配法（动态方法:例如打開wireshark，你去訪問server80端口，就會看到很多介於49152 到 65535 之间這種由作業系統分配的暫時的port號）">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-03-03T16:26:22+00:00">
    <meta property="article:modified_time" content="2022-03-03T16:26:22+00:00">

  <meta itemprop="name" content="網路協議">
  <meta itemprop="description" content="TCP/IP 目前TCP/IP協議泛指現在網路公認使用的所有協議
7層 整理來講，為了方便區分這麼多協議的種類，我們將其分成了5層 各別舉個例子: 應用層 http 需要瀏覽器這種應用程式來拆包 傳輸層 TCP 需要三向交握確認連線 網路層 IP 需要IP當地址 連結層 ARP 需要找出實體MAC 物理層 網路線
這些協議，從瀏覽器發出封包時，經過機器，需要的資料會一層包過一層
請求 在傳輸層裡，每一個封包都需要回覆收到，沒收到的話，會將該請求反覆重試，然而使用者自在F12裡面只會看到一次請求，事實上網路線裡面的資料已經來來回回好幾百次
封包大小 每一層的協議都有規定其封包大小，其中IPV4最大為 65575 bytes大概就65kb左右
然後封包又包在幀裡面
乙太網路 在數據連結層會用到的技術名，一開始用於區域網路(微星狀或匯流排)的傳輸 連結層會用到MAC，知道兩台電腦的MAC就可以互向通信
網際網路 從網路層開始，有了IP開始了點對點的傳輸 回環地址 127.0.0.1 廣播地址 區網內最後一個IP位址，所以沒有一定
每個路由器會緩存一個到下個IP的路由表 有了ARP協議，每個請求有ARP緩存，裡面紀錄了下一個節點IP和MAC對應，這個緩存到了下一個節點就又會變動
乙太網路使用MAC來傳輸數據，但是光有MAC是無法連到網路上其他MAC地址，因為你沒有IP，不知道去哪找MAC，試想一下，如果當初沒有IP這個設計出現，那要維護全世界的MAC表這個數據量會有多龐大，所以IP和MAC缺一不可
ifconfig ifconfig 命令归属于 net-tools 工具集。net-tools 起源于 BSD，自 2001 年起，Linux 社区已经停止对其进行维护。 一些 Linux 发行版已经停止支持 net-tools，只支持 iproute2，在这些 Linux 版本中，只能使用 ip addr 命令查看 IP 地址，使用 ifconfig 会提示命名不存在
port號 傳輸層，port號是一個虛擬的概念，並無實際上的硬體做對應，大概來說每個port號可以對應道不同的程序，為什麼有65535的限制是因為TCP當初協定定義是2的16次方-1，並不是有什麼硬體限制 标准既定的端口号（静态方法: 例如HTTP 80端口，其他的軟體自定義的就落在1024 到 49151 之间 时序分配法（动态方法:例如打開wireshark，你去訪問server80端口，就會看到很多介於49152 到 65535 之间這種由作業系統分配的暫時的port號）">
  <meta itemprop="datePublished" content="2022-03-03T16:26:22+00:00">
  <meta itemprop="dateModified" content="2022-03-03T16:26:22+00:00">
  <meta itemprop="wordCount" content="207">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="網路協議">
  <meta name="twitter:description" content="TCP/IP 目前TCP/IP協議泛指現在網路公認使用的所有協議
7層 整理來講，為了方便區分這麼多協議的種類，我們將其分成了5層 各別舉個例子: 應用層 http 需要瀏覽器這種應用程式來拆包 傳輸層 TCP 需要三向交握確認連線 網路層 IP 需要IP當地址 連結層 ARP 需要找出實體MAC 物理層 網路線
這些協議，從瀏覽器發出封包時，經過機器，需要的資料會一層包過一層
請求 在傳輸層裡，每一個封包都需要回覆收到，沒收到的話，會將該請求反覆重試，然而使用者自在F12裡面只會看到一次請求，事實上網路線裡面的資料已經來來回回好幾百次
封包大小 每一層的協議都有規定其封包大小，其中IPV4最大為 65575 bytes大概就65kb左右
然後封包又包在幀裡面
乙太網路 在數據連結層會用到的技術名，一開始用於區域網路(微星狀或匯流排)的傳輸 連結層會用到MAC，知道兩台電腦的MAC就可以互向通信
網際網路 從網路層開始，有了IP開始了點對點的傳輸 回環地址 127.0.0.1 廣播地址 區網內最後一個IP位址，所以沒有一定
每個路由器會緩存一個到下個IP的路由表 有了ARP協議，每個請求有ARP緩存，裡面紀錄了下一個節點IP和MAC對應，這個緩存到了下一個節點就又會變動
乙太網路使用MAC來傳輸數據，但是光有MAC是無法連到網路上其他MAC地址，因為你沒有IP，不知道去哪找MAC，試想一下，如果當初沒有IP這個設計出現，那要維護全世界的MAC表這個數據量會有多龐大，所以IP和MAC缺一不可
ifconfig ifconfig 命令归属于 net-tools 工具集。net-tools 起源于 BSD，自 2001 年起，Linux 社区已经停止对其进行维护。 一些 Linux 发行版已经停止支持 net-tools，只支持 iproute2，在这些 Linux 版本中，只能使用 ip addr 命令查看 IP 地址，使用 ifconfig 会提示命名不存在
port號 傳輸層，port號是一個虛擬的概念，並無實際上的硬體做對應，大概來說每個port號可以對應道不同的程序，為什麼有65535的限制是因為TCP當初協定定義是2的16次方-1，並不是有什麼硬體限制 标准既定的端口号（静态方法: 例如HTTP 80端口，其他的軟體自定義的就落在1024 到 49151 之间 时序分配法（动态方法:例如打開wireshark，你去訪問server80端口，就會看到很多介於49152 到 65535 之间這種由作業系統分配的暫時的port號）">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        My New Hugo Site
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  
  <article class="flex-l mw8 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">網路協議</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2022-03-03T16:26:22Z">March 3, 2022</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id="tcpip">TCP/IP</h1>
<p>目前TCP/IP協議泛指現在網路公認使用的所有協議</p>
<h1 id="7層">7層</h1>
<p>整理來講，為了方便區分這麼多協議的種類，我們將其分成了5層
各別舉個例子:
應用層 http  需要瀏覽器這種應用程式來拆包
傳輸層 TCP   需要三向交握確認連線
網路層 IP    需要IP當地址
連結層 ARP   需要找出實體MAC
物理層 網路線</p>
<p>這些協議，從瀏覽器發出封包時，經過機器，需要的資料會一層包過一層</p>
<h1 id="請求">請求</h1>
<p>在傳輸層裡，每一個封包都需要回覆收到，沒收到的話，會將該請求反覆重試，然而使用者自在F12裡面只會看到一次請求，事實上網路線裡面的資料已經來來回回好幾百次</p>
<h1 id="封包大小">封包大小</h1>
<p>每一層的協議都有規定其封包大小，其中IPV4最大為 65575 bytes大概就65kb左右</p>
<p>然後封包又包在幀裡面</p>
<h1 id="乙太網路">乙太網路</h1>
<p>在數據連結層會用到的技術名，一開始用於區域網路(微星狀或匯流排)的傳輸
連結層會用到MAC，知道兩台電腦的MAC就可以互向通信</p>
<h1 id="網際網路">網際網路</h1>
<p>從網路層開始，有了IP開始了點對點的傳輸
回環地址 127.0.0.1
廣播地址 區網內最後一個IP位址，所以沒有一定</p>
<p>每個路由器會緩存一個到下個IP的路由表
有了ARP協議，每個請求有ARP緩存，裡面紀錄了下一個節點IP和MAC對應，這個緩存到了下一個節點就又會變動</p>
<p>乙太網路使用MAC來傳輸數據，但是光有MAC是無法連到網路上其他MAC地址，因為你沒有IP，不知道去哪找MAC，試想一下，如果當初沒有IP這個設計出現，那要維護全世界的MAC表這個數據量會有多龐大，所以IP和MAC缺一不可</p>
<h1 id="ifconfig">ifconfig</h1>
<p>ifconfig 命令归属于 net-tools 工具集。net-tools 起源于 BSD，自 2001 年起，Linux 社区已经停止对其进行维护。
一些 Linux 发行版已经停止支持 net-tools，只支持 iproute2，在这些 Linux 版本中，只能使用 ip addr 命令查看 IP 地址，使用 ifconfig 会提示命名不存在</p>
<h1 id="port號">port號</h1>
<p>傳輸層，port號是一個虛擬的概念，並無實際上的硬體做對應，大概來說每個port號可以對應道不同的程序，為什麼有65535的限制是因為TCP當初協定定義是2的16次方-1，並不是有什麼硬體限制
标准既定的端口号（静态方法: 例如HTTP 80端口，其他的軟體自定義的就落在1024 到 49151 之间
时序分配法（动态方法:例如打開wireshark，你去訪問server80端口，就會看到很多介於49152 到 65535 之间這種由作業系統分配的暫時的port號）</p>
<h1 id="socket">socket</h1>
<p>是作業系統網路API的名字
负责监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作监听 Socket，一个叫作已连接 Socket，连接建立成功之后，双方开始通过 read 和 write 函数来读写数据
如果你留心过 Nginx 里面 PHP-FPM 的配置，就会发现有两种方式将 PHP 动态请求转发给 PHP-FPM，一种是 IP 地址+端口号，例如：127.0.0.1:9000，一种是 Socket 文件，例如：unix:/run/php/php7.1-fpm.sock。这里也可以表明，Socket 在 Linux 中确实以文件形式存在，由于不需要建立额外的网络请求，所以后者效率更高，但是由于是本地文件，所以不能跨机器访问，如果 Nginx 和 PHP-FPM 部署在不同的机器，只能通过前一种方式转发请求</p>
<h1 id="併發量">併發量</h1>
<p>理論上: 最大 TCP 连接数 = 客户端 IP 数 × 客户端端口数。对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数，约为 2 的 48 次方。
實際上: ocket 都是文件，所以首先要通过 ulimit 配置文件描述符的数目；另一个限制是内存，按上面的数据结构，每个 TCP 连接都要占用一定内存，操作系统是有限的。</p>
<p>姑且不論上述的內存，要如何盡量處理高併發呢?</p>
<ol>
<li>多進程</li>
<li>多線程
C10K 问题（一台机器要维护 1 万个连接，就要创建 1 万个进程或者线程，操作系统是无法承受的。
维持 1 亿用户在线需要 10 万台服务器，成本太高了</li>
<li>多路IO复用
所谓多路 IO 复用可以简单理解为一个线程维护多个 Socket文件（前面多进程或多线程都是一个进程或线程维护一个 Socket），这也有两种实现方式：轮询和事件通知。
所谓轮询就是调用内核的 select 函数监听文件描述符集合是否有变化
所谓事件通知，就是某个文件描述符发生变化，调用 epoll 函数主动通知</li>
</ol>
<h1 id="telnet">telnet</h1>
<p>telnet也是一個協定名稱，通常開23port
也是早期登入BBS的工具名，所以幾乎所有電腦都有裝，可以用來測PORT，所以跟你server有沒有開23port無關，他就是一個工具可以來測port</p>
<h1 id="ssh">ssh</h1>
<p>相對於telnet比較安全的協議</p>
<p>中間人攻擊:
如果攻击者插在用户与远程主机之间，用伪造的公钥，获取用户的登录密码，再用这个密码登录远程主机，那么 SSH 的安全机制就荡然无存了。
因为不像 HTTPS 协议，SSH 协议的公钥是没有认证中心（CA）公证的，也就是说，都是自己签发的。</p>
<p>如何應對中間人攻擊
第一次登入遠端主機時，會提示ECDSA的公鑰fingerprint
此時可以比對是否與遠端主機的公鑰fingerprint相同，可以通过 ssh-keyscan 命令结合ssh-keygen 得到</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>ssh-keyscan -t ECDSA -p 22 laravelacademy.org
</span></span><span style="display:flex;"><span>ssh-keygen -E sha256 -lf ~/.ssh/known_hosts
</span></span></code></pre></div><p>比對完成之後，輸入yes，服务器 SSH 公钥会添加到本地的<code>~/.ssh/known_hosts</code> 文件里面
<a href="https://github.com/zbinlin/blog/blob/master/resolve-ssh-connect-same-ip-in-diff-host.md">https://github.com/zbinlin/blog/blob/master/resolve-ssh-connect-same-ip-in-diff-host.md</a></p>
<p><a href="https://docs.github.com/en/enterprise-cloud@latest/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints">https://docs.github.com/en/enterprise-cloud@latest/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints</a></p>
<h1 id="rpcremote-procedure-call">RPC(Remote Procedure Call)</h1>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="http://localhost:1313/" >
    &copy;  My New Hugo Site 2025 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
