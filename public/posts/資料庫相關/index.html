<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>資料庫相關 | My New Hugo Site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="何謂資料工程師
https://ithelp.ithome.com.tw/articles/10234925
索引資料結構
一文了解数据库索引：哈希、B-Tree 与LSM
Mysql的DB引擎
MyISAM與InnoDB
postgres的命名規則
資料表的命名方面，很多框架都依循著資料表的命名應該是單數，這個不成文規定，所以在 yii 框架的資料表 user 資料表是單數命名
laravel 的 model 也會是單數命名，然後會假設資料表為複數命名
但是在 postgres 裡面
user 不能當作 table 的名字，是保留字
如果要用的話，就一定要加雙引號 &ldquo;user&rdquo; ，所以表的名子如果是 users 情況會簡單些
所以其實資料表的命名就視情況而定吧
題外話：restapi 的命名規則，url 呈現的會是複數 users
如何定義主鍵 primary key
大家都是怎麼定義自己資料庫裡面的 primary key?
正規化(Normalization)
降低資料的「重覆性」與避免「更新異常」的情況發生。
正規化的精神就是讓資料庫中重複的欄位資料減到最少，並且能快速的找到資料，以提高關聯性資料庫的效能。
第一考量：簡單就好。通常會先思考資料本身就能做 PK，那當然就用資料欄位。
第二考量：效率至上。資料量巨大、且有大量 join，那就考慮使用 auto increment 欄位當 PK。
第三考量：程式單純且易維護。資料本身需要三個以上的欄位才能做 PK，那也考慮用 auto increment 欄位當 PK。
第四考量：資料庫對 PK 或其它 index 有最佳化，那就看它 prefer 用什麼欄位。

系統 OO 化.
小系統用 Int,流水號,不要用字串,int 是電腦處理基礎單位,所以排序,索引..最快
分散式 DB 用 GUID 全世界每一個資料拋過來都不會沖到,而且是 Client 端,App 端產生
PK 給 App 給 DB 關聯看,所以只要不重複,容易電腦計算,如果給 Users 識別用,我會再用一組有規律的 Key 讓 Users 記

正規化規則
正規化的解釋名詞都相當晦澀，這個時候有例子，比較容易幫助理解，你會發現你設計資料表的同時，一般都已經符合到第三正規化">
    <meta name="generator" content="Hugo 0.152.2">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    


    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/%E8%B3%87%E6%96%99%E5%BA%AB%E7%9B%B8%E9%97%9C/">
    

    <meta property="og:url" content="http://localhost:1313/posts/%E8%B3%87%E6%96%99%E5%BA%AB%E7%9B%B8%E9%97%9C/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="資料庫相關">
  <meta property="og:description" content="何謂資料工程師 https://ithelp.ithome.com.tw/articles/10234925
索引資料結構 一文了解数据库索引：哈希、B-Tree 与LSM
Mysql的DB引擎 MyISAM與InnoDB
postgres的命名規則 資料表的命名方面，很多框架都依循著資料表的命名應該是單數，這個不成文規定，所以在 yii 框架的資料表 user 資料表是單數命名 laravel 的 model 也會是單數命名，然後會假設資料表為複數命名
但是在 postgres 裡面
user 不能當作 table 的名字，是保留字
如果要用的話，就一定要加雙引號 “user” ，所以表的名子如果是 users 情況會簡單些
所以其實資料表的命名就視情況而定吧
題外話：restapi 的命名規則，url 呈現的會是複數 users
如何定義主鍵 primary key 大家都是怎麼定義自己資料庫裡面的 primary key?
正規化(Normalization) 降低資料的「重覆性」與避免「更新異常」的情況發生。 正規化的精神就是讓資料庫中重複的欄位資料減到最少，並且能快速的找到資料，以提高關聯性資料庫的效能。
第一考量：簡單就好。通常會先思考資料本身就能做 PK，那當然就用資料欄位。
第二考量：效率至上。資料量巨大、且有大量 join，那就考慮使用 auto increment 欄位當 PK。
第三考量：程式單純且易維護。資料本身需要三個以上的欄位才能做 PK，那也考慮用 auto increment 欄位當 PK。
第四考量：資料庫對 PK 或其它 index 有最佳化，那就看它 prefer 用什麼欄位。
系統 OO 化. 小系統用 Int,流水號,不要用字串,int 是電腦處理基礎單位,所以排序,索引..最快 分散式 DB 用 GUID 全世界每一個資料拋過來都不會沖到,而且是 Client 端,App 端產生 PK 給 App 給 DB 關聯看,所以只要不重複,容易電腦計算,如果給 Users 識別用,我會再用一組有規律的 Key 讓 Users 記 正規化規則 正規化的解釋名詞都相當晦澀，這個時候有例子，比較容易幫助理解，你會發現你設計資料表的同時，一般都已經符合到第三正規化">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-05-15T09:09:20+00:00">
    <meta property="article:modified_time" content="2020-05-15T09:09:20+00:00">
    <meta property="article:tag" content="交易">

  <meta itemprop="name" content="資料庫相關">
  <meta itemprop="description" content="何謂資料工程師 https://ithelp.ithome.com.tw/articles/10234925
索引資料結構 一文了解数据库索引：哈希、B-Tree 与LSM
Mysql的DB引擎 MyISAM與InnoDB
postgres的命名規則 資料表的命名方面，很多框架都依循著資料表的命名應該是單數，這個不成文規定，所以在 yii 框架的資料表 user 資料表是單數命名 laravel 的 model 也會是單數命名，然後會假設資料表為複數命名
但是在 postgres 裡面
user 不能當作 table 的名字，是保留字
如果要用的話，就一定要加雙引號 “user” ，所以表的名子如果是 users 情況會簡單些
所以其實資料表的命名就視情況而定吧
題外話：restapi 的命名規則，url 呈現的會是複數 users
如何定義主鍵 primary key 大家都是怎麼定義自己資料庫裡面的 primary key?
正規化(Normalization) 降低資料的「重覆性」與避免「更新異常」的情況發生。 正規化的精神就是讓資料庫中重複的欄位資料減到最少，並且能快速的找到資料，以提高關聯性資料庫的效能。
第一考量：簡單就好。通常會先思考資料本身就能做 PK，那當然就用資料欄位。
第二考量：效率至上。資料量巨大、且有大量 join，那就考慮使用 auto increment 欄位當 PK。
第三考量：程式單純且易維護。資料本身需要三個以上的欄位才能做 PK，那也考慮用 auto increment 欄位當 PK。
第四考量：資料庫對 PK 或其它 index 有最佳化，那就看它 prefer 用什麼欄位。
系統 OO 化. 小系統用 Int,流水號,不要用字串,int 是電腦處理基礎單位,所以排序,索引..最快 分散式 DB 用 GUID 全世界每一個資料拋過來都不會沖到,而且是 Client 端,App 端產生 PK 給 App 給 DB 關聯看,所以只要不重複,容易電腦計算,如果給 Users 識別用,我會再用一組有規律的 Key 讓 Users 記 正規化規則 正規化的解釋名詞都相當晦澀，這個時候有例子，比較容易幫助理解，你會發現你設計資料表的同時，一般都已經符合到第三正規化">
  <meta itemprop="datePublished" content="2020-05-15T09:09:20+00:00">
  <meta itemprop="dateModified" content="2020-05-15T09:09:20+00:00">
  <meta itemprop="wordCount" content="1065">
  <meta itemprop="keywords" content="交易">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="資料庫相關">
  <meta name="twitter:description" content="何謂資料工程師 https://ithelp.ithome.com.tw/articles/10234925
索引資料結構 一文了解数据库索引：哈希、B-Tree 与LSM
Mysql的DB引擎 MyISAM與InnoDB
postgres的命名規則 資料表的命名方面，很多框架都依循著資料表的命名應該是單數，這個不成文規定，所以在 yii 框架的資料表 user 資料表是單數命名 laravel 的 model 也會是單數命名，然後會假設資料表為複數命名
但是在 postgres 裡面
user 不能當作 table 的名字，是保留字
如果要用的話，就一定要加雙引號 “user” ，所以表的名子如果是 users 情況會簡單些
所以其實資料表的命名就視情況而定吧
題外話：restapi 的命名規則，url 呈現的會是複數 users
如何定義主鍵 primary key 大家都是怎麼定義自己資料庫裡面的 primary key?
正規化(Normalization) 降低資料的「重覆性」與避免「更新異常」的情況發生。 正規化的精神就是讓資料庫中重複的欄位資料減到最少，並且能快速的找到資料，以提高關聯性資料庫的效能。
第一考量：簡單就好。通常會先思考資料本身就能做 PK，那當然就用資料欄位。
第二考量：效率至上。資料量巨大、且有大量 join，那就考慮使用 auto increment 欄位當 PK。
第三考量：程式單純且易維護。資料本身需要三個以上的欄位才能做 PK，那也考慮用 auto increment 欄位當 PK。
第四考量：資料庫對 PK 或其它 index 有最佳化，那就看它 prefer 用什麼欄位。
系統 OO 化. 小系統用 Int,流水號,不要用字串,int 是電腦處理基礎單位,所以排序,索引..最快 分散式 DB 用 GUID 全世界每一個資料拋過來都不會沖到,而且是 Client 端,App 端產生 PK 給 App 給 DB 關聯看,所以只要不重複,容易電腦計算,如果給 Users 識別用,我會再用一組有規律的 Key 讓 Users 記 正規化規則 正規化的解釋名詞都相當晦澀，這個時候有例子，比較容易幫助理解，你會發現你設計資料表的同時，一般都已經符合到第三正規化">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        My New Hugo Site
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  
  <article class="flex-l mw8 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">資料庫相關</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2020-05-15T09:09:20Z">May 15, 2020</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id="何謂資料工程師">何謂資料工程師</h1>
<p><a href="https://ithelp.ithome.com.tw/articles/10234925">https://ithelp.ithome.com.tw/articles/10234925</a></p>
<h1 id="索引資料結構">索引資料結構</h1>
<p>一文了解数据库索引：哈希、B-Tree 与LSM</p>
<h1 id="mysql的db引擎">Mysql的DB引擎</h1>
<p>MyISAM與InnoDB</p>
<h1 id="postgres的命名規則">postgres的命名規則</h1>
<p>資料表的命名方面，很多框架都依循著資料表的命名應該是單數，這個不成文規定，所以在 yii 框架的資料表 user 資料表是單數命名
laravel 的 model 也會是單數命名，然後會假設資料表為複數命名</p>
<p>但是在 postgres 裡面</p>
<p>user 不能當作 table 的名字，是保留字</p>
<p>如果要用的話，就一定要加雙引號 &ldquo;user&rdquo; ，所以表的名子如果是 users 情況會簡單些</p>
<p>所以其實資料表的命名就視情況而定吧</p>
<p>題外話：restapi 的命名規則，url 呈現的會是複數 users</p>
<h1 id="如何定義主鍵-primary-key">如何定義主鍵 primary key</h1>
<p><a href="https://ithelp.ithome.com.tw/questions/10143595">大家都是怎麼定義自己資料庫裡面的 primary key?</a></p>
<h1 id="正規化normalization">正規化(Normalization)</h1>
<p>降低資料的「重覆性」與避免「更新異常」的情況發生。
正規化的精神就是讓資料庫中重複的欄位資料減到最少，並且能快速的找到資料，以提高關聯性資料庫的效能。</p>
<p>第一考量：簡單就好。通常會先思考資料本身就能做 PK，那當然就用資料欄位。</p>
<p>第二考量：效率至上。資料量巨大、且有大量 join，那就考慮使用 auto increment 欄位當 PK。</p>
<p>第三考量：程式單純且易維護。資料本身需要三個以上的欄位才能做 PK，那也考慮用 auto increment 欄位當 PK。</p>
<p>第四考量：資料庫對 PK 或其它 index 有最佳化，那就看它 prefer 用什麼欄位。</p>
<ol>
<li>系統 OO 化.</li>
<li>小系統用 Int,流水號,不要用字串,int 是電腦處理基礎單位,所以排序,索引..最快</li>
<li>分散式 DB 用 GUID 全世界每一個資料拋過來都不會沖到,而且是 Client 端,App 端產生</li>
<li>PK 給 App 給 DB 關聯看,所以只要不重複,容易電腦計算,如果給 Users 識別用,我會再用一組有規律的 Key 讓 Users 記</li>
</ol>
<h1 id="正規化規則">正規化規則</h1>
<p>正規化的解釋名詞都相當晦澀，這個時候有例子，比較容易幫助理解，你會發現你設計資料表的同時，一般都已經符合到第三正規化</p>
<h2 id="第一正規化">第一正規化</h2>
<ul>
<li>定義:
欄位的原子性，關聯式資料庫專屬，欄位的資料不能再分解</li>
<li>情境:
當一個欄位有機會存在著多筆資料時，無法事先得知欄位長度，因此，必須要預留很大的空間給這些欄位, 如此反而造成儲存空間的浪費</li>
<li>解決方法：
拆筆數
缺點:即第二正規劃會遇到的情境</li>
</ul>
<h2 id="第二正規化">第二正規化</h2>
<ul>
<li>定義:
表中的紀錄是唯一的</li>
<li>情境:
當要對某欄位資料進行新增時，必須連同其他欄位也新增
更新時必須要複合多個欄位才能更新正確
刪除時，如果有紀錄該欄位的資料只有一筆，有可能直接抹除該欄位的資料</li>
<li>解決方法：
經過第一正規化之後再去除部份相依
設置主鍵或是複合鍵(唯一)
當一張表的多筆資料有許多欄位重複時,這張表有複合鍵時，其他欄位必須完全相依這兩個複合的欄位，拆表</li>
<li>缺點:會有資料重複</li>
</ul>
<h2 id="第三正規化">第三正規化</h2>
<ul>
<li>定義:表中不要有冗餘的數據，如果能夠被推倒出來，就不單獨設計一個欄位來存放
去除遞移相依，就是與主鍵無關的欄位，非相依於主鍵的欄位</li>
<li>情境:單純設置主鍵，也是會有資料重複的問題</li>
<li>解決方法：劃分好欄位，拆表</li>
<li>缺點:過度正規劃，例如需要計算的欄位</li>
</ul>
<h1 id="acid">ACID</h1>
<h2 id="原子性atomicity">原子性（Atomicity）</h2>
<p>一個交易是一個單元工作,步驟要嘛全部執行成功，若有一個失敗，則整個交易宣告失敗</p>
<h2 id="一致性consistency">一致性（Consistency）</h2>
<p>交易要能夠 rollback</p>
<h2 id="隔離行為isolation-behavior">隔離行為（Isolation behavior）</h2>
<p>交易與交易之間，必須互不干擾，好像同時間就只有自己的交易存在一樣,那這種隔離行為必須要和鎖來做搭配
以下情境都是建立在有交易，可能發生的狀況</p>
<p>然後對於單行的操作 insert update 沒有transation包起來的語句 ，DB預設都是會自動commit的，如果要關閉的話</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">set</span> autocommit<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span></code></pre></div><p>參考：
<a href="https://openhome.cc/Gossip/HibernateGossip/IsolationLevel.html">簡介隔離層級</a>
<a href="https://segmentfault.com/a/1190000014133576">MySQL InnoDB锁机制全面解析分享</a></p>
<p>沒有對資料庫進行鎖定可能出現的問題：</p>
<ul>
<li>
<p>更新遺失（lost update）
基本上就是指某個交易對<strong>欄位</strong>進行更新的資訊，因另一個交易的介入而遺失
會出現在可重複讀取RR(repeatable read)層級的情況，
例如：b 交易的 rollback 導致 a 交易的更新資料消失，因為回到 a 交易還沒更新的時候，但 a 因該要更新完  這種情況稱為(first lost update)</p>
<pre tabindex="0"><code>交易 A 更新欄位 1
交易 B 更新欄位 1
交易 A COMMIT
交易 B ROLLBACK
</code></pre><p>例如：當兩個交易讀到同一欄位值，a 交易的 commit 導致 b 交易的更新資料消失，因為 a 交易延遲導致 b 交易結果被覆蓋，但 b 應該是最後結果(second lost update)</p>
<pre tabindex="0"><code>交易 A 更新欄位 1
交易 B 更新欄位 1
交易 B COMMIT
交易 A COMMIT
</code></pre></li>
<li>
<p>髒讀（dirty read）
读到别的事务没有提交的数据
兩個交易同時進行，在其中一個交易更新資料前，另一個交易讀取了尚未 COMMIT 的資料
例如：a 交易的 rollback 讓 b 交易讀到未確認的資料</p>
<pre tabindex="0"><code>交易 A 更新欄位 1
交易 B 讀取欄位 1
交易 A ROLLBACK
交易 B COMMIT
</code></pre></li>
<li>
<p>無法重複的讀取（unrepeatable read）
前读取的数据，被别的事务改变了，再读就跟原来不一样了
某個交易在交易期間兩次讀取同一欄位的資料並不一致，以致你交易期間重複讀取的資料不一致</p>
<pre tabindex="0"><code>交易 A 讀取欄位 1
交易 B 更新欄位 1
交易 B COMMIT
交易 A 讀取欄位 1
</code></pre></li>
<li>
<p>幻讀（phantom read）這個所需要的鎖的粒度，和上面三種不同
第一次读的时候发现什么都没有，另一个事务偷偷放了东西进去，再去访问的时候惊讶地居然发现有东西了</p>
<pre tabindex="0"><code>交易 A 進行兩次查詢，在兩次查詢之中有個交易 B **插入**一筆新資料或**刪除**一筆新資料，資料多一筆或少一筆，跟update無關
交易 A 進行查詢得到五筆資料
交易 B 插入一筆資料
交易 B COMMIT
交易 A 進行查詢得到六筆資料
</code></pre><p>或是</p>
<pre tabindex="0"><code>交易 A 進行查詢id=99沒有紀錄
交易 B 插入一筆id=99資料
交易 B COMMIT
交易 A 進行查詢id=99沒有紀錄
交易 A 更新id=99紀錄
交易 A 查詢id=99
上面這個例子的第4步需要解釋一下，
因為可重复读的事务B内查询与开始时刻一致（快照），但本事务内的更新操作会更新快照。因此第4步查询的与一开始的一致，为空，第5步在本事务内执行更新操作后就会重新生成一次查询。
</code></pre><p>案例:<a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1245268672511968">Repeatable Read</a></p>
</li>
</ul>
<p>面對以上問題，鎖定資料庫可以解決，但是不同的鎖對效能影響不同
因此會根據<strong>讀寫的頻繁程度</strong>來設定不同的交易隔離層級（transaction isolation level）：</p>
<p>在此說明讀和寫是兩個分開的動作，雖然在交易期間會兩個做搭配，做為一個交易，但資料庫在封鎖功能時是分開封鎖的
以一個需要讀取，更新，提交的交易來說 一共有三個步驟，兩個交易交錯
A和B併發，扣除掉第一個一定是A交易讀取的話，就有C5取2種不同情況，以下還沒有加入rollback以及重複讀取的情況的情況，不然更複雜</p>
<pre tabindex="0"><code>Ar  Br  Au  Ac  Bu  Bc
Ar  Br  Au  Bu  Bc  Ac
Ar  Br  Au  Bu  Ac  Bc
Ar  Br  Bu  Bc  Au  Ac
Ar  Br  Bu  Au  Ac  Bc
Ar  Br  Bu  Au  Bc  Ac
Ar  Au  Ac  Br  Bu  Bc   預期的正常情況
Ar  Au  Br  Ac  Bu  Bc
Ar  Au  Br  Bu  Ac  Bc
Ar  Au  Br  Bu  Bc  Ac
</code></pre><p>以下4個層級的鎖，為隱式鎖定
○代表通過，但通過可能會有副作用
×代表被阻止(延遲)</p>
<ul>
<li>
<p>read uncommited
至少保證：「A 交易已寫入但尚未確認的資料，B 交易僅可作讀取動作」。
A 交易在寫入但未提交，B 交易的寫入會被延後至 A 提交之後。
<strong>未確認的寫入會阻止(延遲)其他交易的寫入</strong>
有髒讀的風險
有重複讀取的風險
有幻讀的風險
<strong>避免更新遺失的問題</strong>，但是會有讀取錯誤的問題，期間如果有人讀取，資料就會不相同，如果你後悔rollback了，會導致你更新的資料不正確</p>
<pre tabindex="0"><code>Ar  Br  Au  Ac  Bu  Bc  ○
Ar  Br  Au  Bu  Bc  Ac  ×
Ar  Br  Au  Bu  Ac  Bc  ×
Ar  Br  Bu  Bc  Au  Ac  ○
Ar  Br  Bu  Au  Ac  Bc  ×
Ar  Br  Bu  Au  Bc  Ac  ×
Ar  Au  Ac  Br  Bu  Bc  ○
Ar  Au  Br  Ac  Bu  Bc  ○
Ar  Au  Br  Bu  Ac  Bc  ×
Ar  Au  Br  Bu  Bc  Ac  ×
</code></pre><p>雖然這個層級有4種能通過，但是這4總情況如果有rollback的話，髒讀情形會很嚴重，因為沒有限制讀取，其他層級加上rollback都不會發生髒讀
以上通過的會伴隨著髒讀和重複讀取的風險</p>
</li>
<li>
<p>read commited
至少要保證：「交易讀取的資料必須是已確認的資料」
<strong>未確認的寫入交易會阻止(延遲)其它交易的讀取</strong>，但不影響寫入會有更新遺失的問題，但這影響效能較大
其中這裡面的讀取，除非你有加<strong>顯示鎖</strong>的關鍵字，不然都是<strong>非一致性鎖定讀</strong>(又稱為快照讀)，就是我不會等待交易A鎖的釋放，而是去讀取該行版本的<strong>最新快照</strong>
有重複讀取的風險
有幻讀的風險
更新遺失的風險</p>
<pre tabindex="0"><code>Ar  Br  Au  Ac  Bu  Bc  ○ 交易A讀取庫存欄位5個，交易B讀取庫存欄位5個，交易A更新庫存為4個，交易A提交，交易B更新庫存為4個，交易B提交==&gt;通過，更新遺失
Ar  Br  Au  Bu  Bc  Ac  ○
Ar  Br  Au  Bu  Ac  Bc  ○ 交易A讀取庫存欄位5個，交易B讀取庫存欄位5個，交易A更新庫存為4個，交易B更新庫存為4個，交易A提交，交易B提交==&gt;通過，更新遺失
Ar  Br  Bu  Bc  Au  Ac  ○
Ar  Br  Bu  Au  Ac  Bc  ○
Ar  Br  Bu  Au  Bc  Ac  ○
Ar  Au  Ac  Br  Bu  Bc  ○
Ar  Au  Br  Ac  Bu  Bc  × 交易A讀取庫存欄位5個，交易A更新庫存為4個，交易B讀取庫存欄位5個(此時被阻止(延遲)，因為交易A寫入尚未提交)
Ar  Au  Br  Bu  Ac  Bc  ×
Ar  Au  Br  Bu  Bc  Ac  ×
</code></pre><p>有7種情形能通過，可以避免髒讀，因為未提交的讀取被限制住了，但是無法保證交易期間資料的一致性，期間如果有人寫入而且提交了，欄位值就會變</p>
</li>
<li>
<p>repeatable read
至少保證：「同一交易內兩次讀取的資料必須相同」
<strong>未確認的讀取，影響其他交易的寫入</strong>
其中這裡面的讀取，除非你有加<strong>顯示鎖</strong>的關鍵字，不然都是<strong>非一致性鎖定讀</strong>(又稱為快照讀)，就是我不會等待交易A鎖的釋放，而是去讀取該行在<strong>交易A一開始時的快照</strong>
有幻讀的風險
更新遺失的風險
//todo 待確認  可以解决的两个问题是unrepeatable read和seocond lost update??(<a href="https://blog.51cto.com/lsieun/1827383">https://blog.51cto.com/lsieun/1827383</a>)</p>
<pre tabindex="0"><code>Ar  Br  Au  Ac  Bu  Bc  ○ 交易A讀取庫存欄位5個，交易B讀取庫存欄位5個，交易A更新庫存為4個，交易A提交，交易B更新庫存為4個，交易B提交==&gt;通過，但更新遺失
Ar  Br  Au  Bu  Bc  Ac  × 交易A讀取庫存欄位5個，交易B讀取庫存欄位5個，交易A更新庫存為4個，交易B更新庫存為4個(此時被阻止，因為交易A讀取尚未提交)
Ar  Br  Au  Bu  Ac  Bc  ×
Ar  Br  Bu  Bc  Au  Ac  × 交易A讀取庫存欄位5個，交易B讀取庫存欄位5個，交易B更新庫存為4個(此時被延遲，因為交易A讀取尚未提交)
Ar  Br  Bu  Au  Ac  Bc  ×
Ar  Br  Bu  Au  Bc  Ac  ×
Ar  Au  Ac  Br  Bu  Bc  ○ 
Ar  Au  Br  Ac  Bu  Bc  ○ 交易A讀取庫存欄位5個，交易A更新庫存為4個，交易B讀取庫存欄位5個，交易A提交，交易B更新庫存為4個，交易B提交==&gt;通過，但更新遺失
Ar  Au  Br  Bu  Ac  Bc  × 交易A讀取庫存欄位5個，交易A更新庫存為4個，交易B讀取庫存欄位5個，交易B更新庫存為4個(此時被阻止(延遲)，因為交易A讀取尚未提交)
Ar  Au  Br  Bu  Bc  Ac  ×
</code></pre><p>有3種情形能通過，避免 unrepeatable read   我在讀的期間你就是不能寫，伴隨著更新遺失和幻讀的風險</p>
<p>更新遺失
//todo 資料庫的原子性，單一update語句是否有更新遺失的問題?
在RR層級下，update會先select for date(當前讀)，所以理論上應該是不會拿到舊的?
update語句RR階層自帶select for update， 鎖一加上要等到commit或rollback階段才能解，所以如果是很熱門的數據欄位，例如商品的庫存，更新這種會上鎖阻塞的操作最好留在交易流程的後半段
也就是整個交易流程 可能就變成 鎖用戶資金=&gt;插入訂單=&gt;更新庫存，庫存這張表的更新留到最後，影響比較小</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">UPDATE</span> COUNTERS <span style="color:#66d9ef">SET</span> VALUE <span style="color:#f92672">=</span> VALUE<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">WHERE</span> <span style="color:#66d9ef">KEY</span> <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;FOO;
</span></span></span></code></pre></div><p>更新遺失</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-php" data-lang="php"><span style="display:flex;"><span>$db<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">transaction</span><span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">begin</span>();
</span></span><span style="display:flex;"><span>$value <span style="color:#f92672">=</span> $db<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">query</span>(<span style="color:#e6db74">&#34;select value from counters where key =&#39;FOO&#39;&#34;</span>)<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">column</span>();
</span></span><span style="display:flex;"><span>$db<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">exec</span>(<span style="color:#e6db74">&#34;UPDATE COUNTERS SET VALUE = </span><span style="color:#e6db74">$value</span><span style="color:#e6db74"> WHERE KEY =&#39;FOO&#39;&#34;</span>);
</span></span><span style="display:flex;"><span>$db<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">transaction</span><span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">commit</span>();
</span></span></code></pre></div></li>
<li>
<p>serializable
<strong>未確認的讀取，影響其他交易的讀取</strong>   <br>
A 交易讀取時，B 交易若要寫入，就必須循序，A 交易寫入時，B 交易無論讀取或寫入都必須循序</p>
<pre tabindex="0"><code>  Ar  Br  Au  Ac  Bu  Bc  ×
  Ar  Br  Au  Bu  Bc  Ac  ×
  Ar  Br  Au  Bu  Ac  Bc  ×
  Ar  Br  Bu  Bc  Au  Ac  ×
  Ar  Br  Bu  Au  Ac  Bc  ×
  Ar  Br  Bu  Au  Bc  Ac  ×
  Ar  Au  Ac  Br  Bu  Bc  ○
  Ar  Au  Br  Ac  Bu  Bc  ×
  Ar  Au  Br  Bu  Ac  Bc  ×
  Ar  Au  Br  Bu  Bc  Ac  ×
</code></pre><p>有1種情況能通過
如何實作序列化的交易呢(<a href="https://xlk3099.github.io/post/ddia_chapter7/">https://xlk3099.github.io/post/ddia_chapter7/</a>)</p>
<ul>
<li>Literally executing transactions in a serial order, representative: redis, cost: can only work on a single CPU core.</li>
<li>Two phase locking(2PL): 统治了几十年，但现在很多 application avoid using it， 因为性能问题, 悲观锁</li>
<li>SSI（serializable snapshot isolation）： 新贵，use an optimistic approach， 乐观锁</li>
</ul>
</li>
</ul>
<p>以上四個為資料庫的4個不同層級的锁，read uncommited 和 serializable這兩個交易層級的索我們不考慮，且由於資料庫在功能封鎖上，不一定符合實際情形，所以我們會搭應用程式上的鎖來對其做補強</p>
<p>顯式鎖定
InnoDB默认使用<strong>行锁</strong>
InnoDB采用的是<a href="https://www.jianshu.com/p/d1c42fe4c4ed">两阶段锁定协议</a>（two-phase locking protocol）
亦即锁只有在执行 COMMIT 或者 ROLLBACK 的时候才会释放
InnoDB 也支持通过特定的语句进行显式锁定，这些语句不属于SQL规范（这些锁定提示经常被滥用，实际上应当尽量避免使用）</p>
<ul>
<li>SELECT &hellip; LOCK IN SHARE MODE  (serializable層級底下才默認select加共享鎖，其他層級可以自己加)</li>
<li>SELECT &hellip; FOR UPDATE (reapeatable read層級底下默認對增刪改加入排他鎖，select讀的話要自己加)</li>
</ul>
<p>以上兩個讀取的動作稱為，<strong>一致性鎖定讀</strong>，当前读</p>
<ul>
<li>LOCK TABLES (不須在交易內執行)</li>
<li>UNLOCK TABLES (不須再交易內執行)</li>
</ul>
<h3 id="mvcc">MVCC</h3>
<p>是通过保存数据在某个时间点的快照来实现的。每个事务读到的数据项都是⼀个历史快照，被称为快照读，不同于当前读的是快照 读读到的数据可能不是最新的，但是快照隔离能使得在整个事务看到的数据都是它启动时的数据状态。</p>
<h3 id="当前读">当前读</h3>
<p>像select lock in share mode( 共享锁),select for update ; update, insert ,delete( 排他锁) 这些操作都是⼀种当前读，为什么叫当前读? 就是它读取的是 记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进⾏加锁。</p>
<h3 id="快照读">快照读</h3>
<p>像不加锁的select 操作就是快照读，即不加锁的⾮阻塞读;</p>
<p>快照读的前提是隔离级别不是未提交读和串⾏化级别，因为未提交读总是读取最新的数据⾏，⽽不是符合当前事务版本的数据⾏。⽽串⾏化则会对所有读取的⾏都加锁</p>
<h3 id="select-for-update">select for update</h3>
<p>參考:<a href="https://blog.51cto.com/u_15101587/2623974">MySQL数据库select for update探究</a></p>
<p>接下來的情境都以InnoDB默認的RR層級鎖來當預設環境，且尚未commit的情況</p>
<p>Q: 我交易A select for update了，那我交易B可以select該行資料嗎?</p>
<p>A: 可以 select 操作讀取的是該行的快照，所以交易B讀取不影響且讀取到的會試舊值，但如果你要更新時，RR層級下你會被延遲</p>
<p>Q: 我交易A select for update了，那我交易B可以select for update該行資料嗎?</p>
<p>A: 不可以 select for update 讀取的是當前的資料(當前讀)，但由於交易A已經對該行施行排他鎖了，所以不能再加鎖</p>
<p>Q: 我交易A update了 我交易B可以select for update嗎?</p>
<p>A: 會被延遲查不到結果，直到A commit，最後雖然交易B還沒結束，但select for update可以讀到最新值，因為是當前讀，此時交易內兩次的讀取就不同了</p>
<h3 id="樂觀鎖定optimistic-locking">樂觀鎖定（Optimistic Locking）</h3>
<p>樂觀的認為資料很少發生同時存取的問題，通常在資料庫層級上設為 read-commited 隔離層級，並實行樂觀鎖定。
read-commited 可以避免 dirty read，但是 lost update,的情形必須要改善，可以讓應用程式在更新前檢查資料有沒有重複
乐观锁是指在获取数据时候不加锁，乐观的认为操作不会有冲突，在update的时候再去检查冲突。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">begin</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> balance <span style="color:#66d9ef">from</span> account <span style="color:#66d9ef">where</span> id<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 得到balance=100;然后计算balance=100+50=150
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">update</span> account <span style="color:#66d9ef">set</span> balance <span style="color:#f92672">=</span> <span style="color:#ae81ff">150</span> <span style="color:#66d9ef">where</span> id<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">and</span> balance <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">commit</span>;
</span></span></code></pre></div><p>改善的方法分為
先更新為主（First commit wins）
後更新的為主（Last commit wins）
合併衝突更新（Merge conflicting update）</p>
<h3 id="悲觀鎖定pessimistic-locking">悲觀鎖定（Pessimistic Locking）</h3>
<p>悲觀的認定每次資料存取時，其它的客戶端也會存取同一筆資料，因此對相關的資料進行鎖定，直到自己操作完成後解除鎖定。
這樣的鎖定叫做排他鎖。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">begin</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> account <span style="color:#66d9ef">where</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">update</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">update</span> account <span style="color:#66d9ef">set</span> balance<span style="color:#f92672">=</span><span style="color:#ae81ff">150</span> <span style="color:#66d9ef">where</span> id <span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">commit</span>;
</span></span></code></pre></div><p>适用场景</p>
<p>一、悲观锁</p>
<p>用来解决读-写冲突和写-写冲突的的加锁并发控制</p>
<p>适用于写多读少，写冲突严重的情况，因为悲观锁是在读取数据的时候就加锁的，读多的场景会需要频繁的加锁和很多的的等待时间，而在写冲突严重的情况下使用悲观锁可以保证数据的一致性</p>
<p>数据一致性要求高</p>
<p>可以解决脏读，幻读，不可重复读，第一类更新丢失，第二类更新丢失的问题</p>
<p>二、乐观锁</p>
<p>解决写-写冲突的无锁并发控制</p>
<p>适用于读多写少，因为如果出现大量的写操作，写冲突的可能性就会增大，业务层需要不断重试，这会大大降低系统性能</p>
<p>数据一致性要求不高，但要求非常高的响应速度</p>
<p>无法解决脏读，幻读，不可重复读，但是可以解决更新丢失问题</p>
<p>三、MVCC(多版本併發控制)</p>
<p>解决读-写冲突的无锁并发控制</p>
<p>与上面两者结合，提升它们的读性能</p>
<p>可以解决脏读，幻读，不可重复读等事务问题，更新丢失问题除外</p>
<p><a href="https://www.cnblogs.com/chenpingzhao/p/5041967.html">【mysql】关于悲观锁</a>
<a href="https://blog.csdn.net/weixin_39947314/article/details/113720708">mysql悲观锁和乐观优缺点_乐观锁、悲观锁和MVCC各是什么</a></p>
<h2 id="死鎖">死鎖</h2>
<p>參考：
<a href="https://segmentfault.com/a/1190000022732257">死鎖</a></p>
<pre tabindex="0"><code>事務A更新id=1，更新id=2，提交
事務B更新id=2，更新id=1，提交
死鎖的情形發生在:
事務A更新id=1
事務B更新id=2
事務A等待事務B釋放id=2鎖
事務B等待事務A釋放id=1鎖
兩個事務互相等待，導致死鎖
</code></pre><p>两阶段锁协议，整个事务分为两个阶段，前一个阶段为加锁，后一个阶段为解锁。在加锁阶段，事务只能加锁，也可以操作数据，但不能解锁，直到事务释放第一个锁，就进入解锁阶段( commit or rollback)，此过程中事务只能解锁，也可以操作数据，不能再加锁。两阶段锁协议使得事务具有较高的并发度，因为解锁不必发生在事务结尾。它的不足是没有解决死锁的问题，因为它在加锁阶段没有顺序要求。如两个事务分别申请了A, B锁，接着又申请对方的锁，此时进入死锁状态。(<a href="https://www.cnblogs.com/zszmhd/p/3365220.html">https://www.cnblogs.com/zszmhd/p/3365220.html</a>)</p>
<h2 id="持續性durability">持續性（Durability）</h2>
<p>交易一旦成功，所有的變更就必須保存下來，就是你一但commit之後，即便是硬體的損壞也不應該丟影響資料，
在有叢集的情況下就是需要其他的節點有寫入資料之後，此commit才算成功，那如果是單一節點的資料庫呢?
就需要採用ssd這種不會關掉電源就資料流失的硬體，最主要是依靠wal(writing ahead log)，依靠這個log來recover</p>
<h1 id="base">BASE</h1>
<p><a href="http://garyliutw.blogspot.com/2014/05/mongodb-nosql.html">MongoDB 學習筆記</a></p>
<h2 id="basically-abalible">Basically Abalible</h2>
<h2 id="soft-state">soft state</h2>
<h2 id="eventual-consistency">eventual consistency</h2>
<h1 id="遭遇狀況">遭遇狀況</h1>
<h2 id="group-by-和-select-的關係">GROUP BY 和 select 的關係</h2>
<p>因為 group by 一定會有幾筆資料需要合併，這個時候就會需要搭配一些函數例如 sum count 某些欄位，不然他會不知道要留下哪筆資料
<a href="https://stackoverflow.com/questions/19601948/must-appear-in-the-group-by-clause-or-be-used-in-an-aggregate-function">https://stackoverflow.com/questions/19601948/must-appear-in-the-group-by-clause-or-be-used-in-an-aggregate-function</a></p>
<h1 id="資料庫優化">資料庫優化</h1>
<p><a href="https://blog.csdn.net/qq_28284093/article/details/81031670">https://blog.csdn.net/qq_28284093/article/details/81031670</a></p>
<h1 id="大家在系統中有沒有使用-資料庫的-view">大家在系統中有沒有使用 資料庫的 VIEW</h1>
<p><a href="https://ithelp.ithome.com.tw/questions/10122148">https://ithelp.ithome.com.tw/questions/10122148</a>
另一個原因
<a href="https://youtu.be/Y-mJXOnoSx4">https://youtu.be/Y-mJXOnoSx4</a>
影片下面留言有人的前端需要統一用 activeRecode 來存取物件，但是資料又是多表格 join 的，該如何才能正常存取屬性
就有人回答用 view 然後把他當作一般的表來創 model</p>
<h1 id="高併發">高併發</h1>
<p>關鍵字：資料庫其實本身不是用來承載高併發請求的</p>
<h1 id="mysql读写分离后的延迟解决方案">MySQL读写分离后的延迟解决方案</h1>
<p><a href="https://www.cnblogs.com/zhangchaocoming/p/13033064.html">https://www.cnblogs.com/zhangchaocoming/p/13033064.html</a></p>
<h1 id="uuid">uuid</h1>
<p>UUID 来设置用户唯一 ID，相比自增 ID 而言，UUID 的好处是不依赖于数据库的自增 ID，可以分布式生成，另外，从安全角度来说，UUID 是没有规律的随机字符串，无法被用户猜测发起恶意攻击或接口遍历。</p>
<h1 id="php中pdo关闭连接的问题">PHP中PDO关闭连接的问题</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span>mysql<span style="color:#f92672">&gt;</span><span style="color:#66d9ef">show</span> processlist;
</span></span></code></pre></div><p><a href="https://blog.51cto.com/u_15127608/3287543">https://blog.51cto.com/u_15127608/3287543</a></p>
<p>可以列出sleep中的線程，我們一般的請求其實不會刻意去關閉資料庫連結的，如何發現呢?
程式碼裡面sleep(10)就可以發現資料庫連結跟著卡10秒，所以理論上php不做太耗時的運算，線程會很快結束，不會sleep太久</p>
<h1 id="mysql主從延遲的解決方案">Mysql主從延遲的解決方案</h1>
<p><a href="https://segmentfault.com/a/1190000040821444">MySQL主从延迟解决办法</a></p>
<h1 id="mysql-insert-on-duplicate">mysql insert on duplicate</h1>
<p>效能比replace好，如果要附帶刪除功能可以參考這篇
在更新時，增加do_delete欄位
<a href="https://stackoverflow.com/questions/11495090/mysql-insert-on-duplicate-key-delete">https://stackoverflow.com/questions/11495090/mysql-insert-on-duplicate-key-delete</a></p>
<h1 id="樹狀結構">樹狀結構</h1>
<p><a href="https://blog.csdn.net/weixin_34258782/article/details/86073946?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ETopBlog-1.topblog&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ETopBlog-1.topblog&amp;utm_relevant_index=1">[ mongoDB ] - 文档型数据库设计模式-如何存储树形数据 [转]</a>
<a href="https://columns.chicken-house.net/2019/06/01/nested-query/">架構面試題 #3, RDBMS 處理樹狀結構的技巧</a></p>
<ul class="pa0">
  
   <li class="list di">
     <a href="/tags/%E4%BA%A4%E6%98%93/" class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">交易</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="http://localhost:1313/" >
    &copy;  My New Hugo Site 2025 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
