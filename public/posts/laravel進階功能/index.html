<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>laravel進階功能 | My New Hugo Site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="symfony
一個開源的框架，因為致力於做出PHP比較底層的原件，所以很多php框架都底層都用他，laravel也不例外，其中尤其重要的是
http-kernel這個元件
生命週期
Laravel 執行原理分析與原始碼分析,底層看這篇足矣
Service Container
laravel 服務容器管理 class 的依賴關係的一種方式，例如 route model binding，讓你可以依賴注入，
好處是當你的建構子需要改東西時，你不用在個別有 new 他的地方改 code，你只需要改一個地方
https://laracasts.com/series/laravel-6-from-scratch/episodes/39?autoplay=true
那由於 laravel 最自動幫你找命名空間下的 class,有的話他就會幫你注入，你不必自己去綁定進 app 這個 container，但是如果你是個 interface，laravel 就不能幫你實體化了
在 AppServiceProvider
public function register(){
    $this-&gt;app-&gt;bind(PaymentGateway::class,function($app){
        return new PaymentGateway(&#39;usd&#39;);
    });
}
View Composer
解決的痛點是，如果各個 controller 都需要用到某個 model 的資料來應用在各個 view 上面，
就不需要在每個 controller 上面都都進行 query，而且當 query 語句要變，你只需要改一個地方
在 AppServiceProvider
public function boot(){
    // option1 每一個view都進行query耗效能
    View::share(&#39;channels&#39;,Channel::orderBy(&#39;name&#39;)-&gt;get());
    // option2 指定view進行query
    View::composer([&#39;post.*&#39;,&#39;channel.index&#39;],function($view){
        $view-&gt;with(&#39;channels&#39;,Channel::orderBy(&#39;name&#39;)-&gt;get());
    });
}
Polymorphic Relationships
https://www.itdaan.com/blog/2011/03/22/1861cf1574aa7995b47010f2e11f87e2.html">
    <meta name="generator" content="Hugo 0.152.2">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    


    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/laravel%E9%80%B2%E9%9A%8E%E5%8A%9F%E8%83%BD/">
    

    <meta property="og:url" content="http://localhost:1313/posts/laravel%E9%80%B2%E9%9A%8E%E5%8A%9F%E8%83%BD/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="laravel進階功能">
  <meta property="og:description" content="symfony 一個開源的框架，因為致力於做出PHP比較底層的原件，所以很多php框架都底層都用他，laravel也不例外，其中尤其重要的是 http-kernel這個元件
生命週期 Laravel 執行原理分析與原始碼分析,底層看這篇足矣
Service Container laravel 服務容器管理 class 的依賴關係的一種方式，例如 route model binding，讓你可以依賴注入， 好處是當你的建構子需要改東西時，你不用在個別有 new 他的地方改 code，你只需要改一個地方
https://laracasts.com/series/laravel-6-from-scratch/episodes/39?autoplay=true
那由於 laravel 最自動幫你找命名空間下的 class,有的話他就會幫你注入，你不必自己去綁定進 app 這個 container，但是如果你是個 interface，laravel 就不能幫你實體化了
在 AppServiceProvider
public function register(){ $this-&gt;app-&gt;bind(PaymentGateway::class,function($app){ return new PaymentGateway(&#39;usd&#39;); }); } View Composer 解決的痛點是，如果各個 controller 都需要用到某個 model 的資料來應用在各個 view 上面， 就不需要在每個 controller 上面都都進行 query，而且當 query 語句要變，你只需要改一個地方
在 AppServiceProvider
public function boot(){ // option1 每一個view都進行query耗效能 View::share(&#39;channels&#39;,Channel::orderBy(&#39;name&#39;)-&gt;get()); // option2 指定view進行query View::composer([&#39;post.*&#39;,&#39;channel.index&#39;],function($view){ $view-&gt;with(&#39;channels&#39;,Channel::orderBy(&#39;name&#39;)-&gt;get()); }); } Polymorphic Relationships https://www.itdaan.com/blog/2011/03/22/1861cf1574aa7995b47010f2e11f87e2.html">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-10-05T11:02:05+00:00">
    <meta property="article:modified_time" content="2020-10-05T11:02:05+00:00">
    <meta property="article:tag" content="Service Container">

  <meta itemprop="name" content="laravel進階功能">
  <meta itemprop="description" content="symfony 一個開源的框架，因為致力於做出PHP比較底層的原件，所以很多php框架都底層都用他，laravel也不例外，其中尤其重要的是 http-kernel這個元件
生命週期 Laravel 執行原理分析與原始碼分析,底層看這篇足矣
Service Container laravel 服務容器管理 class 的依賴關係的一種方式，例如 route model binding，讓你可以依賴注入， 好處是當你的建構子需要改東西時，你不用在個別有 new 他的地方改 code，你只需要改一個地方
https://laracasts.com/series/laravel-6-from-scratch/episodes/39?autoplay=true
那由於 laravel 最自動幫你找命名空間下的 class,有的話他就會幫你注入，你不必自己去綁定進 app 這個 container，但是如果你是個 interface，laravel 就不能幫你實體化了
在 AppServiceProvider
public function register(){ $this-&gt;app-&gt;bind(PaymentGateway::class,function($app){ return new PaymentGateway(&#39;usd&#39;); }); } View Composer 解決的痛點是，如果各個 controller 都需要用到某個 model 的資料來應用在各個 view 上面， 就不需要在每個 controller 上面都都進行 query，而且當 query 語句要變，你只需要改一個地方
在 AppServiceProvider
public function boot(){ // option1 每一個view都進行query耗效能 View::share(&#39;channels&#39;,Channel::orderBy(&#39;name&#39;)-&gt;get()); // option2 指定view進行query View::composer([&#39;post.*&#39;,&#39;channel.index&#39;],function($view){ $view-&gt;with(&#39;channels&#39;,Channel::orderBy(&#39;name&#39;)-&gt;get()); }); } Polymorphic Relationships https://www.itdaan.com/blog/2011/03/22/1861cf1574aa7995b47010f2e11f87e2.html">
  <meta itemprop="datePublished" content="2020-10-05T11:02:05+00:00">
  <meta itemprop="dateModified" content="2020-10-05T11:02:05+00:00">
  <meta itemprop="wordCount" content="215">
  <meta itemprop="keywords" content="Service Container">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="laravel進階功能">
  <meta name="twitter:description" content="symfony 一個開源的框架，因為致力於做出PHP比較底層的原件，所以很多php框架都底層都用他，laravel也不例外，其中尤其重要的是 http-kernel這個元件
生命週期 Laravel 執行原理分析與原始碼分析,底層看這篇足矣
Service Container laravel 服務容器管理 class 的依賴關係的一種方式，例如 route model binding，讓你可以依賴注入， 好處是當你的建構子需要改東西時，你不用在個別有 new 他的地方改 code，你只需要改一個地方
https://laracasts.com/series/laravel-6-from-scratch/episodes/39?autoplay=true
那由於 laravel 最自動幫你找命名空間下的 class,有的話他就會幫你注入，你不必自己去綁定進 app 這個 container，但是如果你是個 interface，laravel 就不能幫你實體化了
在 AppServiceProvider
public function register(){ $this-&gt;app-&gt;bind(PaymentGateway::class,function($app){ return new PaymentGateway(&#39;usd&#39;); }); } View Composer 解決的痛點是，如果各個 controller 都需要用到某個 model 的資料來應用在各個 view 上面， 就不需要在每個 controller 上面都都進行 query，而且當 query 語句要變，你只需要改一個地方
在 AppServiceProvider
public function boot(){ // option1 每一個view都進行query耗效能 View::share(&#39;channels&#39;,Channel::orderBy(&#39;name&#39;)-&gt;get()); // option2 指定view進行query View::composer([&#39;post.*&#39;,&#39;channel.index&#39;],function($view){ $view-&gt;with(&#39;channels&#39;,Channel::orderBy(&#39;name&#39;)-&gt;get()); }); } Polymorphic Relationships https://www.itdaan.com/blog/2011/03/22/1861cf1574aa7995b47010f2e11f87e2.html">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        My New Hugo Site
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  
  <article class="flex-l mw8 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">laravel進階功能</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2020-10-05T11:02:05Z">October 5, 2020</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id="symfony">symfony</h1>
<p>一個開源的框架，因為致力於做出PHP比較底層的原件，所以很多php框架都底層都用他，laravel也不例外，其中尤其重要的是
http-kernel這個元件</p>
<h1 id="生命週期">生命週期</h1>
<p><a href="https://learnku.com/articles/54613">Laravel 執行原理分析與原始碼分析,底層看這篇足矣</a></p>
<h1 id="service-container">Service Container</h1>
<p>laravel 服務容器管理 class 的依賴關係的一種方式，例如 route model binding，讓你可以依賴注入，
好處是當你的建構子需要改東西時，你不用在個別有 new 他的地方改 code，你只需要改一個地方</p>
<p><a href="https://laracasts.com/series/laravel-6-from-scratch/episodes/39?autoplay=true">https://laracasts.com/series/laravel-6-from-scratch/episodes/39?autoplay=true</a></p>
<p>那由於 laravel 最自動幫你找命名空間下的 class,有的話他就會幫你注入，你不必自己去綁定進 app 這個 container，但是如果你是個 interface，laravel 就不能幫你實體化了</p>
<p>在 AppServiceProvider</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-php" data-lang="php"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">register</span>(){
</span></span><span style="display:flex;"><span>    $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">app</span><span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">bind</span>(<span style="color:#a6e22e">PaymentGateway</span><span style="color:#f92672">::</span><span style="color:#a6e22e">class</span>,<span style="color:#66d9ef">function</span>($app){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">PaymentGateway</span>(<span style="color:#e6db74">&#39;usd&#39;</span>);
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="view-composer">View Composer</h1>
<p>解決的痛點是，如果各個 controller 都需要用到某個 model 的資料來應用在各個 view 上面，
就不需要在每個 controller 上面都都進行 query，而且當 query 語句要變，你只需要改一個地方</p>
<p>在 AppServiceProvider</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-php" data-lang="php"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">boot</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// option1 每一個view都進行query耗效能
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">View</span><span style="color:#f92672">::</span><span style="color:#a6e22e">share</span>(<span style="color:#e6db74">&#39;channels&#39;</span>,<span style="color:#a6e22e">Channel</span><span style="color:#f92672">::</span><span style="color:#a6e22e">orderBy</span>(<span style="color:#e6db74">&#39;name&#39;</span>)<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">get</span>());
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// option2 指定view進行query
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">View</span><span style="color:#f92672">::</span><span style="color:#a6e22e">composer</span>([<span style="color:#e6db74">&#39;post.*&#39;</span>,<span style="color:#e6db74">&#39;channel.index&#39;</span>],<span style="color:#66d9ef">function</span>($view){
</span></span><span style="display:flex;"><span>        $view<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">with</span>(<span style="color:#e6db74">&#39;channels&#39;</span>,<span style="color:#a6e22e">Channel</span><span style="color:#f92672">::</span><span style="color:#a6e22e">orderBy</span>(<span style="color:#e6db74">&#39;name&#39;</span>)<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">get</span>());
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="polymorphic-relationships">Polymorphic Relationships</h1>
<p><a href="https://www.itdaan.com/blog/2011/03/22/1861cf1574aa7995b47010f2e11f87e2.html">https://www.itdaan.com/blog/2011/03/22/1861cf1574aa7995b47010f2e11f87e2.html</a></p>
<p>多態的關聯不是真的表格中的關聯，而是定義在 class 中的關係，程式自己會去找欄位對應的關係
所以不必在建立表格時，設定 fk，也不必而外建立一張表，但要注意這是建立在 eloquent 層，而不是 db 層，如果刪除資料，別的資料並不會有所聯動
<a href="https://youtu.be/6J8vb5_WRBw">https://youtu.be/6J8vb5_WRBw</a></p>
<ul>
<li>1 對 1 的關係 ，不常見
例如： 一個人對應一個身份字號</li>
<li>1 對多的關係，最常見的一種
例如： 一個有多筆訂單</li>
<li>多對多的關係，在實際的表格設計中你就需要設計另外一個表個來存放關聯
例如：一個文章有多個標籤，一個標籤屬於多個文章</li>
</ul>
<h1 id="facades">Facades</h1>
<p>看起來像呼叫靜態方法的設計模式，配合著 service contaier 來做，達到用看似使用靜態方法的 code 來呼叫需要實例化的方法
不用像參數依賴注入一樣不需要在 register 註冊，直接使用更方便，你參數才不會議長串很難看，那跟依賴注入一樣，new 的動作就交給 container</p>
<p>在 AppServiceProvider</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-php" data-lang="php"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">boot</span>(){
</span></span><span style="display:flex;"><span>    $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">app</span><span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">singleton</span>(<span style="color:#e6db74">&#39;Postcard&#39;</span>,<span style="color:#66d9ef">function</span>($app){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">PostcardSendingService</span>(<span style="color:#e6db74">&#39;us&#39;</span>,<span style="color:#e6db74">&#39;600&#39;</span>,<span style="color:#e6db74">&#39;400&#39;</span>);
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="macros">Macros</h1>
<p>用來擴充 laravel 內建 class 方法 的方式，laravel 官網有列可以這樣擴充的清單</p>
<h1 id="pipeline">Pipeline</h1>
<h1 id="repository-pattern">Repository Pattern</h1>
<p>有人主张 controller 應該要愈少行愈清楚越好，
為了不讓 controller 參雜重複太多邏輯，有些人會把邏輯直接放在 model，讓 orm 的 find where 留在 model，但有時候商業邏輯牽扯到兩個 model 時，你是要將他寫在哪一個 model 呢？
所以有些人會特地抽出一層 repository 來，一切看你專案複雜度而定</p>
<p>好處是假如你哪一天 orm 換掉了，controller 和 model 也不會有太大變動，商業邏輯的部份特地切了出來</p>
<p>中小型專案並不建議導入，會增加專案的複雜度</p>
<p>為什 laravel 不內建這設計模式？
因為業界對於這個設計模式沒有一個準則
<a href="https://stackoverflow.com/questions/60295553/creating-laravel-repositories-and-binding-as-service-providers">https://stackoverflow.com/questions/60295553/creating-laravel-repositories-and-binding-as-service-providers</a></p>
<h1 id="lazy-collection">Lazy Collection</h1>
<p>底層是用 php 的 generator 來達成的，配合 for 和 yield 關鍵字，可以幫你省下不少記憶體，算是蠻少用的功能，但需要時就很實用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-php" data-lang="php"><span style="display:flex;"><span><span style="color:#a6e22e">Collection</span><span style="color:#f92672">::</span><span style="color:#a6e22e">times</span>(<span style="color:#ae81ff">100000</span>)<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">map</span>(<span style="color:#66d9ef">function</span>($number){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pow</span>(<span style="color:#ae81ff">2</span>,$number);
</span></span><span style="display:flex;"><span>})<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">all</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">User</span><span style="color:#f92672">::</span><span style="color:#a6e22e">all</span>();
</span></span><span style="display:flex;"><span> <span style="color:#75715e">// vs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">LazyCollection</span><span style="color:#f92672">::</span><span style="color:#a6e22e">times</span>(<span style="color:#ae81ff">100000</span>)<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">map</span>(<span style="color:#66d9ef">function</span>($number){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pow</span>(<span style="color:#ae81ff">2</span>,$number);
</span></span><span style="display:flex;"><span>})<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">all</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">User</span><span style="color:#f92672">::</span><span style="color:#a6e22e">cursor</span>();
</span></span></code></pre></div><h1 id="soft-delete">Soft delete</h1>
<p>這也是很常用的功能
大部分的時候，如果你要刪除使用者，你並不會真的刪除他，而是把他隱藏起來
需要在 migration 做欄位的增加，通常會配合 policy 來實作</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-php" data-lang="php"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> <span style="color:#a6e22e">Illuminate\Database\Eloquent\SoftDeletes</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Post</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Model</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">use</span> <span style="color:#a6e22e">SoftDelets</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">protected</span> $guarded <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="notifications">Notifications</h1>
<p>通知使用者的機器人，通常會有第三方的套件給你用</p>
<h1 id="laravel-design-pattern">laravel design pattern</h1>
<p><a href="https://stackoverflow.com/questions/60029955/when-to-use-repository-vs-service-vs-trait-in-laravel">https://stackoverflow.com/questions/60029955/when-to-use-repository-vs-service-vs-trait-in-laravel</a>
<a href="https://codesource.io/brief-overview-of-design-pattern-used-in-laravel/">https://codesource.io/brief-overview-of-design-pattern-used-in-laravel/</a></p>
<ul class="pa0">
  
   <li class="list di">
     <a href="/tags/service-container/" class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Service Container</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="http://localhost:1313/" >
    &copy;  My New Hugo Site 2025 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
