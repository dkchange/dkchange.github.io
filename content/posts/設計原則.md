---
title: 設計原則
date: 2019-11-05 22:53:01
tags:
categories:
  - [任何路線, 設計原則, 設計模式, 設計規範]
---

# 前言

設計模式的 7 大原則
為了碼復用，增加可維護性,高內聚,低耦合
软件设计原则：原则为我们提供指南，它告诉我们什么是对的，什么是错的。它不会告诉我们如何解决问题。它仅仅给出一些准则，以便我们可以设计好的软件，避免不良的设计。一些常见的原则，比如DRY、OCP、DIP等

软件设计原则，它仅仅告诉你两个模块之间应该如何依赖，但是它并没有告诉如何做

https://wiki.mbalib.com/zh-tw/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F
https://ithelp.ithome.com.tw/articles/10095511


# 7 大设计原则

1. 單一職責原則（Single Responsibility Principle，SRP）
2. 开闭原则（Open Close Principle）
3. 里氏代换原则（Liskov Substitution Principle）
4. 接口隔离原则（Interface Segregation Principle）
5. 依赖倒转原则（Dependence Inversion Principle）

以上5個原則的首字母聯合起來就是SOLID（solid，穩定的）

6. 迪米特法则（Demeter Principle）又叫作最少知识原则（Least Knowledge Principle，LKP)、(Law of Demeter，LoD)
7. 合成复用原则（Composite Reuse Principle）

生活實例可以參考
[设计模式看了又忘，忘了又看](https://juejin.cn/post/6844903854174126088)
其他原則：
dry(Don't repeat yourself)
kiss(keep it simple, stupid)
YAGNI(You aren't gonna need it)
Hollywood Principle(Don’t call us, we’ll call you)

## solid

### SRP Single Responsibility Principle 單一職責原則
說明：做好職責劃分,邏輯和資料不混用
需要：method和interface必須遵守class可不必遵守
例子：註冊、登入
特例：active record 違反這項原則：換來快速的開發效率

### OCP Open Closed Principle 開閉原則
是說模塊應對擴展開放，而對修改關閉。模塊應儘量在不修改原（是“原”，指原來的代碼）代碼的情況下進行擴展
你可以去繼承該class但不要去修改該class
目的:我們常常有修A 錯B的情形發生，A可能被很多地方引用，用繼承的方式去擴展，才能減少這樣的事情發生

### LSP Liskov Substitution Principle 里氏替換原則
主要講的是繼承,繼承會增加耦合性但是為了減少代碼又不可避免,就是教你**好好的用繼承**
程式上只要父類別能出現的地方，子類別就可以出現，並且替換子類別不會產生任何錯誤或異常。但是反過來就不行，子類別能出現的地方，父類別未必能適應。
目的:假如所有繼承的方法，你都去overwrite ，那就違反此項原則，假如塑膠鴨子不會飛，你去繼承鴨子，那塑膠鴨子飛的方法被使用者使用時，就是你overwirte的結果，這樣就是錯誤的繼承，此時如果系統已經運行一陣子，被很多地方依賴，要修改就會是個地獄

### ISP Interface Segregation Principles 介面隔離原則
介面應該是一種角色，不多不少，不幹不該乾的事，該乾的事都要乾
不應該強迫用戶依賴它們未使用的方法，介面又會強迫實作，所以介面的職責要劃分清楚，不然會出現空實作之類的違反LSP
弱型別:
https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle/
強型別:
https://medium.com/%E7%A8%8B%E5%BC%8F%E6%84%9B%E5%A5%BD%E8%80%85/%E4%BD%BF%E4%BA%BA%E7%98%8B%E7%8B%82%E7%9A%84-solid-%E5%8E%9F%E5%89%87-%E4%BB%8B%E9%9D%A2%E9%9A%94%E9%9B%A2%E5%8E%9F%E5%89%87-interface-segregation-principle-50f54473c79e
目的: 我自己將其視為一種封裝，例如:我鴨子抽出 可以飛的介面出來，那如果你要可以飛，你就必須NEW這個有實做可以飛的Class

### DIP Dependency Inversion Principle 依賴反轉原則
高層模組不應依賴低層模組，兩者都應依賴其抽象,就是儘量用抽象和界面

依赖倒置原则，DIP,Dependency Inverse Principle DIP的表述是：

1、高层模块不应该依赖于低层模块, 二者都应该依赖于抽象。

2、抽象不应该依赖于细节,细节应该依赖于抽象。

这里说的“依赖”是使用的意思，如果你调用了一个类的一个方法，就是依赖这个类，如果你直接调用这个类的方法，就是依赖细节，细节就是具体的类，但如果你调用的是它父类或者接口的方法，就是依赖抽象， 所以 DIP 说白了就是不要直接使用具体的子类，而是用它的父类的引用去调用子类的方法，这样就是依赖于抽象，不依赖具体。

其实简单的说，DIP 的好处就是解除耦合，用了 DIP 之后，调用者就不知道被调用的代码是什么，因为调用者拿到的是父类的引用，它不知道具体指向哪个子类的实例，更不知道要调用的方法具体是什么，所以，被调用代码被偷偷换成另一个子类之后，调用者不需要做任何修改， 这就是解耦了。

耦合是怎麼來的 在一段邏輯裡面有new A 你就會和A這個class有耦合，要怎樣才能解耦合? 
依賴其interface 這個我們叫做依賴反轉
改從參數傳進去  這個我們叫做控制反轉
https://www.runoob.com/note/36434
[從被動變主動—依賴反轉]https://ithelp.ithome.com.tw/articles/10191603
[深入理解DIP、IoC、DI以及IoC容器] (http://www.uml.org.cn/sjms/201409021.asp)
[容器範例](https://gitee.com/obamajs/php-base-container/blob/master/Container.php)
## CARP

合成/聚合復用原則（Composite/Aggregate Reuse Principle，CARP）經常又叫做合成復用原則。
儘量使用合成/聚合，儘量不要使用繼承。就是說要少用繼承，多用合成關係來實現，應儘量針對 Interface 編程，而非實現類
讓各個類儘可能少的跟別人聯繫，擴展性和維護性才能提高

## 迪米特法則（Law of Demeter，LoD）

也稱為最少知識原則（Least Knowledge Principle，LKP）
一個對象應對其他對象有儘可能少的瞭解，對於你要呼叫的對象，或者耦合的對象不需要知道的太多
例子: 六度人脈空間
也就是說如果我想聯繫比爾蓋茲，我只要找到我與他之間的六個人，然後藉由這六個人的介紹，我就可以順利的聯繫到比爾蓋茲
參考:[從生活中認識Design Pattern](https://ithelp.ithome.com.tw/articles/10237285)

### tell don't ask

的面向对象编程是告诉对象你要做什么，而不是询问对象的状态后根据状态做行动

